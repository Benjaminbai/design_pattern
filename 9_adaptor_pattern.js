// 适配器模式：将一个类(对象)的接口(方法、属性)转化为用户需要的另一个接口。解决类(对象)之间接口不兼容的问题。

// 优点：
// 已有的功能如果只是接口不兼容，使用适配器适配已有功能，可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码；
// 可扩展性良好，在实现适配器功能的时候，可以调用自己开发的功能，从而方便地扩展系统的功能；
// 灵活性好，因为适配器并没有对原有对象的功能有所影响，如果不想使用适配器了，那么直接删掉即可，不会对使用原有对象的代码有影响；

// 缺点：
// 会让系统变得零乱，明明调用 A，却被适配到了 B，如果系统中这样的情况很多，那么对可阅读性不太友好。如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，可以考虑尽量把文档完善。

// 适配器模式、代理模式以及装饰模式的区别：
// 适配器模式： 原功能不变，只转换了原有接口访问格式；提供一个不一样的接口，由于原来的接口格式不能用了，提供新的接口以满足新场景下的需求；
// 代理模式：原功能不变，但一般是经过限制访问的；提供一模一样的接口，由于不能直接访问目标对象，找个代理来帮忙访问，使用者可以就像访问目标对象一样来访问代理对象；
// 装饰模式：扩展功能，原有功能不变且可直接使用；



var chinaPlug = {
    type: '中国插头',
    chinaInPlug() {
        console.log('开始供电');
    }
};

// 日本插头
var japanPlug = {
    type: '日本插头',
    japanInPlug() {
        console.log('开始供电');
    }
};

// 日本插头电源适配器
function japanPlugAdapter(plug) {
    return {
        chinaInPlug() {
            return plug.japanInPlug();
        }
    }
};

japanPlugAdapter(japanPlug).chinaInPlug();

